<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>ai</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxjs/dist/onnx.min.js"></script>
    <script src="./lib/ndarray-browser-min.js"></script>
    <script src="./lib/image-loader.js"></script>
    <script src="./lib/imagenetClasses.js"></script>
    <style>
        .result {
            background: black;
            height: max-content;
            text-align: center;
            color: white;
            padding: 10px;
            font-size: 20px;
        }
        
        #status {
            height: max-content;
            padding: 10px;
            align-items: center;
            justify-content: center;
            background: black;
        }
        
        video {
            /* width: 400px; */
            /* height: 600px; */
            width: 100%;
            height: 80%;
            display: none;
        }
        
        font {
            font-family: "微软雅黑";
        }
        
        #canvas {
            width: 100%;
        }
    </style>
    <link href="index.css" rel="stylesheet">
</head>

<body>
    <!-- <h1>COVID</h1> -->
    <div>
        <div class="result">COVID Test Strip Reader</div>
        <video id="video" autoplay></video>
        <!-- <button id="snap">Snap Photo</button> -->
        <!-- <canvas id="canvas" hidden="false" width="750" height="560"></canvas> -->
        <canvas id="canvas"></canvas>
        <div id="status">
            <div style="color:purple; font-size: 20px; text-align:center">Result: Invalid</div>
        </div>
        <canvas id="canvas_opencv"></canvas>
        <div class="slidercontainer">
            <!-- <input type="range" min="0" max="255" value="100" class="slider" id="LH"> -->
            <!-- <input type="range" min="0" max="255" value="116" class="slider" id="LH">  -->
            <input type="range" min="0" max="255" value="74" class="slider" id="LH">

            <p><span id="valueLH"></span></p>
        </div>
        <div class="slidercontainer">
            <!-- <input type="range" min="0" max="255" value="150" class="slider" id="LS"> -->
            <!-- <input type="range" min="0" max="255" value="110" class="slider" id="LS"> -->
            <!-- <input type="range" min="0" max="255" value="70" class="slider" id="LS"> -->
            <input type="range" min="0" max="255" value="20" class="slider" id="LS">
            <p><span id="valueLS"></span></p>
        </div>
        <div class="slidercontainer">
            <!-- <input type="range" min="0" max="255" value="0" class="slider" id="LV"> -->
            <!-- <input type="range" min="0" max="255" value="50" class="slider" id="LV"> -->
            <input type="range" min="0" max="255" value="40" class="slider" id="LV">
            <p><span id="valueLV"></span></p>
        </div>
        <div class="slidercontainer">
            <!-- <input type="range" min="0" max="180" value="144" class="slider" id="HH"> -->
            <input type="range" min="0" max="180" value="180" class="slider" id="HH">
            <p><span id="valueHH"></span></p>
        </div>
        <div class="slidercontainer">
            <input type="range" min="0" max="255" value="255" class="slider" id="HS">
            <p><span id="valueHS"></span></p>
        </div>
        <div class="slidercontainer">
            <input type="range" min="0" max="255" value="255" class="slider" id="HV">
            <p><span id="valueHV"></span></p>
        </div>
    </div>
    <div>
        <div id="predictions"></div>
    </div>
    <!-- <script type="module" src="/script.js"></script> -->
    <script type="text/javascript">
        let slider_LH = document.getElementById("LH")
        let slider_LS = document.getElementById("LS")
        let slider_LV = document.getElementById("LV")
        let slider_HH = document.getElementById("HH")
        let slider_HS = document.getElementById("HS")
        let slider_HV = document.getElementById("HV")
        let LH = parseFloat(slider_LH.value)
        let LS = parseFloat(slider_LS.value)
        let LV = parseFloat(slider_LV.value)
        let HH = parseFloat(slider_HH.value)
        let HS = parseFloat(slider_HS.value)
        let HV = parseFloat(slider_HV.value)
        let value_LH = document.getElementById("valueLH")
        let value_LS = document.getElementById("valueLS")
        let value_LV = document.getElementById("valueLV")
        let value_HH = document.getElementById("valueHH")
        let value_HS = document.getElementById("valueHS")
        let value_HV = document.getElementById("valueHV")


        function updateValues() {
            LH = parseFloat(slider_LH.value)
            LS = parseFloat(slider_LS.value)
            LV = parseFloat(slider_LV.value)
            HH = parseFloat(slider_HH.value)
            HS = parseFloat(slider_HS.value)
            HV = parseFloat(slider_HV.value)
            value_LH.innerHTML = slider_LH.value
            value_LS.innerHTML = slider_LS.value
            value_LV.innerHTML = slider_LV.value
            value_HH.innerHTML = slider_HH.value
            value_HS.innerHTML = slider_HS.value
            value_HV.innerHTML = slider_HV.value
        }

        function onOpenCvReady() {
            cv['onRuntimeInitialized'] = () => {
                console.log("OpenCV.js is ready")
                    //video
                if (navigator.mediaDevices === undefined) {
                    navigator.mediaDevices = {};
                }
                // 一些浏览器部分支持 mediaDevices。我们不能直接给对象设置 getUserMedia
                // 因为这样可能会覆盖已有的属性。这里我们只会在没有getUserMedia属性的时候添加它。
                if (navigator.mediaDevices.getUserMedia === undefined) {
                    navigator.mediaDevices.getUserMedia = function(constraints) {

                        // 首先，如果有getUserMedia的话，就获得它
                        var getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;

                        // 一些浏览器根本没实现它 - 那么就返回一个error到promise的reject来保持一个统一的接口
                        if (!getUserMedia) {
                            return Promise.reject(new Error('getUserMedia is not implemented in this browser'));
                        }

                        // 否则，为老的navigator.getUserMedia方法包裹一个Promise
                        return new Promise(function(resolve, reject) {
                            getUserMedia.call(navigator, constraints, resolve, reject);
                        });
                    }
                }

                var video = document.getElementById('video');

                //後置攝像頭
                navigator.mediaDevices.getUserMedia({
                        audio: false,
                        // video: true
                        video: {
                            facingMode: 'environment'
                        }
                    })
                    .then(function(stream) {
                        // 旧的浏览器可能没有srcObject
                        if ("srcObject" in video) {
                            video.srcObject = stream;
                        } else {
                            // 防止在新的浏览器里使用它，应为它已经不再支持了
                            video.src = window.URL.createObjectURL(stream);
                        }
                        video.onloadedmetadata = function(e) {
                            video.width = video.videoWidth;
                            video.height = video.videoHeight;
                            //var snap = document.getElementById('snap');
                            var canvas = document.getElementById('canvas');
                            var canvas_opencv = document.getElementById('canvas_opencv')
                            var ctx = canvas.getContext('2d');
                            var ctx_opencv = canvas_opencv.getContext('2d')
                            var imageData;
                            video.play();

                            function opencv() {
                                let cap = new cv.VideoCapture(video)
                                let src = new cv.Mat(video.height, video.width, cv.CV_8UC4)
                                let rng = new cv.Mat(video.height, video.width, cv.CV_8UC1)
                                let hsv = new cv.Mat(video.height, video.width, cv.CV_8UC1)
                                let edg = new cv.Mat(video.height, video.width, cv.CV_8UC1)
                                let dst = new cv.Mat(video.height, video.width, cv.CV_8UC4)
                                let ctr = cv.Mat.zeros(video.height, video.width, cv.CV_8UC3);
                                let hsv_c = new cv.Mat(video.height * ((1.7 / 17.7) * 0.8), video.width * ((0.7 / 17.7) * 0.8), cv.CV_8UC1)
                                let hsv_t = new cv.Mat(video.height * ((1.7 / 17.7) * 0.8), video.width * ((0.7 / 17.7) * 0.8), cv.CV_8UC1)
                                let rng_c = new cv.Mat(video.height * ((1.7 / 17.7) * 0.8), video.width * ((0.7 / 17.7) * 0.8), cv.CV_8UC1)
                                let rng_t = new cv.Mat(video.height * ((1.7 / 17.7) * 0.8), video.width * ((0.7 / 17.7) * 0.8), cv.CV_8UC1)
                                let hasC = false
                                let hasT = false
                                    //3.4*0.7  6.3*2.1
                                let box_dimension_y = video.videoHeight * 0.8
                                let box_dimension_x = box_dimension_y * (5 / 17.7)
                                let contours = new cv.MatVector();
                                let hierarchy = new cv.Mat();
                                const FPS = 30

                                function processVideo() {
                                    updateValues()
                                    try {
                                        let begin = Date.now()
                                        cap.read(src)

                                        // calculate detection box dimension and drawing the box
                                        let color = new cv.Scalar(0, 0, 255)
                                        let point1_corner = new cv.Point(video.videoWidth / 2 - box_dimension_x / 2, video.videoHeight / 2 - box_dimension_y / 2)
                                        let point1_edge1 = new cv.Point(point1_corner.x, point1_corner.y + video.videoHeight * 0.1)
                                        let point1_edge2 = new cv.Point(point1_corner.x + video.videoHeight * 0.1, point1_corner.y)
                                        cv.line(src, point1_corner, point1_edge1, color, 5, cv.LINE_8, 0)
                                        cv.line(src, point1_corner, point1_edge2, color, 5, cv.LINE_8, 0)
                                        let point2_corner = new cv.Point(video.videoWidth / 2 + box_dimension_x / 2, video.videoHeight / 2 - box_dimension_y / 2)
                                        let point2_edge1 = new cv.Point(point2_corner.x, point1_corner.y + video.videoHeight * 0.1)
                                        let point2_edge2 = new cv.Point(point2_corner.x - video.videoHeight * 0.1, point1_corner.y)
                                        cv.line(src, point2_corner, point2_edge1, color, 5, cv.LINE_8, 0)
                                        cv.line(src, point2_corner, point2_edge2, color, 5, cv.LINE_8, 0)
                                        let point3_corner = new cv.Point(video.videoWidth / 2 + box_dimension_x / 2, video.videoHeight / 2 + box_dimension_y / 2)
                                        let point3_edge1 = new cv.Point(point3_corner.x, point3_corner.y - video.videoHeight * 0.1)
                                        let point3_edge2 = new cv.Point(point3_corner.x - video.videoHeight * 0.1, point3_corner.y)
                                        cv.line(src, point3_corner, point3_edge1, color, 5, cv.LINE_8, 0)
                                        cv.line(src, point3_corner, point3_edge2, color, 5, cv.LINE_8, 0)
                                        let point4_corner = new cv.Point(video.videoWidth / 2 - box_dimension_x / 2, video.videoHeight / 2 + box_dimension_y / 2)
                                        let point4_edge1 = new cv.Point(point4_corner.x, point4_corner.y - video.videoHeight * 0.1)
                                        let point4_edge2 = new cv.Point(point4_corner.x + video.videoHeight * 0.1, point4_corner.y)
                                        cv.line(src, point4_corner, point4_edge1, color, 5, cv.LINE_8, 0)
                                        cv.line(src, point4_corner, point4_edge2, color, 5, cv.LINE_8, 0)

                                        // bgr to hsv
                                        cv.cvtColor(src, hsv, cv.COLOR_BGR2HSV)

                                        // cropping hsv for c and t
                                        rect_c = new cv.Rect(Math.round(point1_corner.x + (2.1 / 17.7) * 0.8 * video.videoHeight), Math.round(point1_corner.y + (6.3 / 17.7) * 0.8 * video.videoHeight), Math.round((0.7 / 17.7) * 0.8 * video.videoHeight), Math.round((1.7 / 17.7) * 0.8 * video.videoHeight))
                                        rect_t = new cv.Rect(Math.round(point1_corner.x + (2.1 / 17.7) * 0.8 * video.videoHeight), Math.round(point1_corner.y + ((6.3 + 1.7) / 17.7) * 0.8 * video.videoHeight), Math.round((0.7 / 17.7) * 0.8 * video.videoHeight), Math.round((1.7 / 17.7) * 0.8 * video.videoHeight))
                                        hsv_c = hsv.roi(rect_c)
                                        hsv_t = hsv.roi(rect_t)

                                        // hsv in range
                                        let lower = [LH, LS, LV, 0];
                                        let higher = [HH, HS, HV, 0];
                                        // let low = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), lower);
                                        // let high = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), higher);
                                        // cv.inRange(hsv, low, high, rng)
                                        let low = new cv.Mat(hsv_c.rows, hsv_c.cols, hsv_c.type(), lower);
                                        let high = new cv.Mat(hsv_c.rows, hsv_c.cols, hsv_c.type(), higher);
                                        cv.inRange(hsv_c, low, high, rng_c)
                                        cv.inRange(hsv_t, low, high, rng_t)

                                        // detect result lines of C & T
                                        hasC = cv.countNonZero(rng_c)
                                        hasT = cv.countNonZero(rng_t)
                                        if (hasC && hasT) {
                                            // cv.putText(src, "Result: Positive", point1_corner, cv.FONT_HERSHEY_SIMPLEX, 1, color, 3, 2)
                                            document.getElementById("status").innerHTML = `<div style="color:red; font-size: 25px; text-align:center">Result: Positive</div>`
                                            console.log("positive")
                                        }
                                        if (!hasC && hasT) {
                                            // cv.putText(src, "Result: Invalid", (100, 100), cv.FONT_HERSHEY_SIMPLEX, 1, color, 3, 2)
                                            document.getElementById("status").innerHTML = `<div style="color:purple; font-size: 25px; text-align:center">Result: Invalid</div>`
                                            console.log("invalid")
                                        }

                                        // canny edge detection
                                        cv.Canny(rng, edg, 200, 600, 3, false)

                                        // find contours
                                        cv.findContours(edg, contours, hierarchy, cv.RETR_TREE, 1);
                                        let cnt = contours.get(0);
                                        for (let i = 0; i < contours.size(); ++i) {
                                            cv.drawContours(ctr, contours, i, color, 1, cv.LINE_8, hierarchy, 100);
                                        }

                                        cv.imshow("canvas_opencv", src.roi(rect_t))

                                        cv.imshow("canvas", src);
                                        let delay = 1000 / FPS - (Date.now() - begin)
                                        setTimeout(processVideo, delay)
                                    } catch (err) {
                                        console.error(err)
                                            // clearInterval(interval)
                                            // interval = setInterval(processVideo, 200)
                                            // location.reload()
                                    }
                                }
                                // setTimeout(processVideo, 1000)
                                processVideo()
                                    // setInterval(processVideo, 200)

                                // getVideoFrame()
                                // ctx.drawImage(video, 0, 0, 750, 560);
                            }
                            setTimeout(opencv, 1000)
                        };
                    })
                    .catch(function(err) {
                        console.log(err.name + ": " + err.message);
                    });

                //get video frame
                function getVideoFrame() {
                    ctx.drawImage(video, 0, 0, 750, 560);
                    ctx_opencv.drawImage(video, 0, 0, 750, 560);
                    imageData = ctx.getImageData(0, 0, 750, 560);
                    //console.log("getVideoFrame");
                }
            }
        }
    </script>
    <!-- <script async src="opencv.js" onload="onOpenCvReady()"></script> -->
    <script async src="https://docs.opencv.org/master/opencv.js" type="text/javascript" onload="onOpenCvReady()"></script>

    <!-- <script async src="opencv.js"></script> -->


</body>

</html>