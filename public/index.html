<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>ai</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxjs/dist/onnx.min.js"></script>
    <script src="./lib/ndarray-browser-min.js"></script>
    <script src="./lib/image-loader.js"></script>
    <script src="./lib/imagenetClasses.js"></script>
    <style>
        .result {
            background: black;
            height: max-content;
            text-align: center;
            color: white;
            padding: 10px;
            font-size: 20px;
        }
        
        #status {
            height: max-content;
            padding: 10px;
            align-items: center;
            justify-content: center;
            background: red;
        }
        
        video {
            /* width: 400px; */
            /* height: 600px; */
            width: 100%;
            height: 80%;
            display: none;
        }
        
        font {
            font-family: "微软雅黑";
        }
        
        #canvas {
            width: 100%;
        }
        
        .detection {
            background: red
        }
        
        .detected {
            background: green !important;
        }
        
        .slidercontainer {
            padding-top: 50px;
            text-align: center;
        }
    </style>
    <link href="index.css" rel="stylesheet">
</head>

<body>
    <!-- <h1>COVID</h1> -->
    <div>
        <div class="result">COVID Test Strip Reader</div>
        <video id="video" autoplay></video>
        <!-- <button id="snap">Snap Photo</button> -->
        <!-- <canvas id="canvas" hidden="false" width="750" height="560"></canvas> -->
        <canvas id="canvas"></canvas>
        <div id="status" class="detection">
            <div style="color:purple; font-size: 20px; text-align:center">Result: Invalid</div>
        </div>
        <div id="logger" style="display:none"></div>
        <div class="slidercontainer">
            White: <input type="range" min="0" max="255" value="100" class="slider" id="thresh_black">
            <p><span id="value_thresh_black" style="display:none"></span></p>
        </div>
        <div class="slidercontainer" style="display:none">
            <input type="range" min="0" max="100" value="70" class="slider" id="white_percent">
            <p><span id="value_white_percent"></span></p>
        </div>
        <div class="slidercontainer" style="display:none">
            <!-- <input type="range" min="0" max="255" value="100" class="slider" id="LH"> -->
            <!-- <input type="range" min="0" max="255" value="116" class="slider" id="LH">  -->
            <input type="range" min="0" max="255" value="74" class="slider" id="LH">
            <p><span id="valueLH"></span></p>
        </div>
        <div class="slidercontainer">
            <!-- <input type="range" min="0" max="255" value="150" class="slider" id="LS"> -->
            <!-- <input type="range" min="0" max="255" value="110" class="slider" id="LS"> -->
            <!-- <input type="range" min="0" max="255" value="70" class="slider" id="LS"> -->
            Red: <input type="range" min="0" max="255" value="40" class="slider" id="LS">
            <p><span id="valueLS" style="display:none"></span></p>
        </div>
        <div class="slidercontainer" style="display:none">
            <!-- <input type="range" min="0" max="255" value="0" class="slider" id="LV"> -->
            <!-- <input type="range" min="0" max="255" value="50" class="slider" id="LV"> -->
            <input type="range" min="0" max="255" value="40" class="slider" id="LV">
            <p><span id="valueLV"></span></p>
        </div>
        <div class="slidercontainer" style="display:none">
            <!-- <input type="range" min="0" max="180" value="144" class="slider" id="HH"> -->
            <input type="range" min="0" max="180" value="180" class="slider" id="HH">
            <p><span id="valueHH"></span></p>
        </div>
        <div class="slidercontainer" style="display:none">
            <input type="range" min="0" max="255" value="255" class="slider" id="HS">
            <p><span id="valueHS"></span></p>
        </div>
        <div class="slidercontainer" style="display:none">
            <input type="range" min="0" max="255" value="255" class="slider" id="HV">
            <p><span id="valueHV"></span></p>
        </div>
        <canvas id="canvas_opencv"></canvas>
    </div>
    <div>
        <div id="predictions"></div>
    </div>
    <!-- <script type="module" src="/script.js"></script> -->
    <script type="text/javascript">
        let slider_LH = document.getElementById("LH")
        let slider_LS = document.getElementById("LS")
        let slider_LV = document.getElementById("LV")
        let slider_HH = document.getElementById("HH")
        let slider_HS = document.getElementById("HS")
        let slider_HV = document.getElementById("HV")
        let LH = parseFloat(slider_LH.value)
        let LS = parseFloat(slider_LS.value)
        let LV = parseFloat(slider_LV.value)
        let HH = parseFloat(slider_HH.value)
        let HS = parseFloat(slider_HS.value)
        let HV = parseFloat(slider_HV.value)
        let value_LH = document.getElementById("valueLH")
        let value_LS = document.getElementById("valueLS")
        let value_LV = document.getElementById("valueLV")
        let value_HH = document.getElementById("valueHH")
        let value_HS = document.getElementById("valueHS")
        let value_HV = document.getElementById("valueHV")

        let slider_thresh = document.getElementById("thresh_black")
        let thresh_black = parseInt(slider_thresh.value)
        let value_thresh_black = document.getElementById("value_thresh_black")

        let slider_white_percent = document.getElementById("white_percent")
        let white_percent = parseInt(slider_thresh.value)
        let value_white_percent = document.getElementById("value_white_percent")


        function updateValues() {
            LH = parseFloat(slider_LH.value)
            LS = parseFloat(slider_LS.value)
            LV = parseFloat(slider_LV.value)
            HH = parseFloat(slider_HH.value)
            HS = parseFloat(slider_HS.value)
            HV = parseFloat(slider_HV.value)
            value_LH.innerHTML = slider_LH.value
            value_LS.innerHTML = slider_LS.value
            value_LV.innerHTML = slider_LV.value
            value_HH.innerHTML = slider_HH.value
            value_HS.innerHTML = slider_HS.value
            value_HV.innerHTML = slider_HV.value

            thresh_black = parseInt(slider_thresh.value)
            value_thresh_black.innerHTML = slider_thresh.value

            white_percent = parseInt(slider_white_percent.value)
            value_white_percent.innerHTML = slider_white_percent.value
        }

        function onOpenCvReady() {
            cv['onRuntimeInitialized'] = () => {
                console.log("OpenCV.js is ready")
                if (navigator.mediaDevices === undefined) {
                    navigator.mediaDevices = {};
                }
                // 一些浏览器部分支持 mediaDevices。我们不能直接给对象设置 getUserMedia
                // 因为这样可能会覆盖已有的属性。这里我们只会在没有getUserMedia属性的时候添加它。
                if (navigator.mediaDevices.getUserMedia === undefined) {
                    navigator.mediaDevices.getUserMedia = function(constraints) {

                        // 首先，如果有getUserMedia的话，就获得它
                        var getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;

                        // 一些浏览器根本没实现它 - 那么就返回一个error到promise的reject来保持一个统一的接口
                        if (!getUserMedia) {
                            return Promise.reject(new Error('getUserMedia is not implemented in this browser'));
                        }

                        // 否则，为老的navigator.getUserMedia方法包裹一个Promise
                        return new Promise(function(resolve, reject) {
                            getUserMedia.call(navigator, constraints, resolve, reject);
                        });
                    }
                }

                var video = document.getElementById('video');
                video.setAttribute('autoplay', '');
                video.setAttribute('muted', '');
                video.setAttribute('playsinline', '');

                //後置攝像頭
                navigator.mediaDevices.getUserMedia({
                        audio: false,
                        // video: true
                        video: {
                            facingMode: 'environment'
                        }
                    })
                    .then(function(stream) {
                        // 旧的浏览器可能没有srcObject
                        if ("srcObject" in video) {
                            video.srcObject = stream;
                        } else {
                            // 防止在新的浏览器里使用它，应为它已经不再支持了
                            video.src = window.URL.createObjectURL(stream);
                        }
                        video.onloadedmetadata = function(e) {
                            video.width = video.videoWidth;
                            video.height = video.videoHeight;
                            //var snap = document.getElementById('snap');
                            var canvas = document.getElementById('canvas');
                            var canvas_opencv = document.getElementById('canvas_opencv')
                            var ctx = canvas.getContext('2d');
                            var ctx_opencv = canvas_opencv.getContext('2d')
                            var imageData;
                            video.play();

                            function opencv() {
                                let cap = new cv.VideoCapture(video)
                                let src = new cv.Mat(video.height, video.width, cv.CV_8UC4)
                                let rng = new cv.Mat(video.height, video.width, cv.CV_8UC1)
                                let hsv = new cv.Mat(video.height, video.width, cv.CV_8UC1)
                                let edg = new cv.Mat(video.height, video.width, cv.CV_8UC1)
                                let dst = new cv.Mat(video.height, video.width, cv.CV_8UC4)
                                let ctr = cv.Mat.zeros(video.height, video.width, cv.CV_8UC3);
                                let hsv_c = new cv.Mat(video.height * ((1.7 / 17.7) * 0.8), video.width * ((0.7 / 17.7) * 0.8), cv.CV_8UC1)
                                let hsv_t = new cv.Mat(video.height * ((1.7 / 17.7) * 0.8), video.width * ((0.7 / 17.7) * 0.8), cv.CV_8UC1)
                                let rng_c = new cv.Mat(video.height * ((1.7 / 17.7) * 0.8), video.width * ((0.7 / 17.7) * 0.8), cv.CV_8UC1)
                                let rng_t = new cv.Mat(video.height * ((1.7 / 17.7) * 0.8), video.width * ((0.7 / 17.7) * 0.8), cv.CV_8UC1)
                                let rng_qr = new cv.Mat(video.height * ((3.0 / 17.7) * 0.8), video.height * ((3.0 / 17.7) * 0.8), cv.CV_8UC1)
                                let src_qr = new cv.Mat(video.height * ((3.0 / 17.7) * 0.8), video.height * ((3.0 / 17.7) * 0.8), cv.CV_8UC1)
                                let hsv_qr = new cv.Mat(video.height * ((3.0 / 17.7) * 0.8), video.height * ((3.0 / 17.7) * 0.8), cv.CV_8UC1)
                                let gray_qr = new cv.Mat(video.height * ((3.0 / 17.7) * 0.8), video.height * ((3.0 / 17.7) * 0.8), cv.CV_8UC1)
                                let blur_qr = new cv.Mat(video.height * ((3.0 / 17.7) * 0.8), video.height * ((3.0 / 17.7) * 0.8), cv.CV_8UC1)
                                let thresh_qr = new cv.Mat(video.height * ((3.0 / 17.7) * 0.8), video.height * ((3.0 / 17.7) * 0.8), cv.CV_8UC1)
                                let kernel_qr = new cv.Mat(video.height * ((3.0 / 17.7) * 0.8), video.height * ((3.0 / 17.7) * 0.8), cv.CV_8UC1)
                                let close_qr = new cv.Mat(video.height * ((3.0 / 17.7) * 0.8), video.height * ((3.0 / 17.7) * 0.8), cv.CV_8UC1)
                                let dilate_qr = new cv.Mat(video.height * ((3.0 / 17.7) * 0.8), video.height * ((3.0 / 17.7) * 0.8), cv.CV_8UC1)
                                let edg_qr = new cv.Mat(video.height * ((3.0 / 17.7) * 0.8), video.height * ((3.0 / 17.7) * 0.8), cv.CV_8UC1)

                                let check1 = new cv.Mat(video.height * ((1.0 / 17.7) * 0.8), video.height * ((2.0 / 17.7) * 0.8), cv.CV_8UC1)
                                let check2 = new cv.Mat(video.height * ((1.0 / 17.7) * 0.8), video.height * ((2.0 / 17.7) * 0.8), cv.CV_8UC1)
                                let check3 = new cv.Mat(video.height * ((1.0 / 17.7) * 0.8), video.height * ((2.0 / 17.7) * 0.8), cv.CV_8UC1)
                                let src_ck1 = new cv.Mat(video.height * ((1.0 / 17.7) * 0.8), video.height * ((2.0 / 17.7) * 0.8), cv.CV_8UC1)
                                let src_ck2 = new cv.Mat(video.height * ((1.0 / 17.7) * 0.8), video.height * ((2.0 / 17.7) * 0.8), cv.CV_8UC1)
                                let src_ck3 = new cv.Mat(video.height * ((1.0 / 17.7) * 0.8), video.height * ((2.0 / 17.7) * 0.8), cv.CV_8UC1)
                                let gray_ck1 = new cv.Mat(video.height * ((1.0 / 17.7) * 0.8), video.height * ((2.0 / 17.7) * 0.8), cv.CV_8UC1)
                                let gray_ck2 = new cv.Mat(video.height * ((1.0 / 17.7) * 0.8), video.height * ((2.0 / 17.7) * 0.8), cv.CV_8UC1)
                                let gray_ck3 = new cv.Mat(video.height * ((1.0 / 17.7) * 0.8), video.height * ((2.0 / 17.7) * 0.8), cv.CV_8UC1)
                                let thresh_ck1 = new cv.Mat(video.height * ((1.0 / 17.7) * 0.8), video.height * ((2.0 / 17.7) * 0.8), cv.CV_8UC1)
                                let thresh_ck2 = new cv.Mat(video.height * ((1.0 / 17.7) * 0.8), video.height * ((2.0 / 17.7) * 0.8), cv.CV_8UC1)
                                let thresh_ck3 = new cv.Mat(video.height * ((1.0 / 17.7) * 0.8), video.height * ((2.0 / 17.7) * 0.8), cv.CV_8UC1)


                                let hasC = false
                                let hasT = false
                                let correctPosition1 = false
                                let correctPosition2 = false
                                let correctPosition3 = false

                                //3.4*0.7  6.3*2.1
                                let box_dimension_y = video.videoHeight * 0.8
                                let box_dimension_x = box_dimension_y * (5 / 17.7)
                                let contours = new cv.MatVector();
                                let hierarchy = new cv.Mat();
                                let contours_qr = new cv.MatVector();

                                let color = new cv.Scalar(0, 0, 255)
                                let color_detecting = new cv.Scalar(255, 255, 0, 255)
                                let color_positive = new cv.Scalar(255, 0, 0, 255)
                                let color_negative = new cv.Scalar(0, 255, 0, 255)
                                let color_invalid = new cv.Scalar(255, 0, 255, 255)


                                const FPS = 30

                                function processVideo() {
                                    updateValues()
                                    try {
                                        let begin = Date.now()
                                        cap.read(src)

                                        // calculate detection box dimension and drawing the box
                                        let point1_corner = new cv.Point(video.videoWidth / 2 - box_dimension_x / 2, video.videoHeight / 2 - box_dimension_y / 2)
                                        let point1_edge1 = new cv.Point(point1_corner.x, point1_corner.y + video.videoHeight * 0.1)
                                        let point1_edge2 = new cv.Point(point1_corner.x + video.videoHeight * 0.1, point1_corner.y)
                                        cv.line(src, point1_corner, point1_edge1, color, 5, cv.LINE_8, 0)
                                        cv.line(src, point1_corner, point1_edge2, color, 5, cv.LINE_8, 0)
                                        let point2_corner = new cv.Point(video.videoWidth / 2 + box_dimension_x / 2, video.videoHeight / 2 - box_dimension_y / 2)
                                        let point2_edge1 = new cv.Point(point2_corner.x, point1_corner.y + video.videoHeight * 0.1)
                                        let point2_edge2 = new cv.Point(point2_corner.x - video.videoHeight * 0.1, point1_corner.y)
                                        cv.line(src, point2_corner, point2_edge1, color, 5, cv.LINE_8, 0)
                                        cv.line(src, point2_corner, point2_edge2, color, 5, cv.LINE_8, 0)
                                        let point3_corner = new cv.Point(video.videoWidth / 2 + box_dimension_x / 2, video.videoHeight / 2 + box_dimension_y / 2)
                                        let point3_edge1 = new cv.Point(point3_corner.x, point3_corner.y - video.videoHeight * 0.1)
                                        let point3_edge2 = new cv.Point(point3_corner.x - video.videoHeight * 0.1, point3_corner.y)
                                        cv.line(src, point3_corner, point3_edge1, color, 5, cv.LINE_8, 0)
                                        cv.line(src, point3_corner, point3_edge2, color, 5, cv.LINE_8, 0)
                                        let point4_corner = new cv.Point(video.videoWidth / 2 - box_dimension_x / 2, video.videoHeight / 2 + box_dimension_y / 2)
                                        let point4_edge1 = new cv.Point(point4_corner.x, point4_corner.y - video.videoHeight * 0.1)
                                        let point4_edge2 = new cv.Point(point4_corner.x + video.videoHeight * 0.1, point4_corner.y)
                                        cv.line(src, point4_corner, point4_edge1, color, 5, cv.LINE_8, 0)
                                        cv.line(src, point4_corner, point4_edge2, color, 5, cv.LINE_8, 0)

                                        let point_detecting = new cv.Point(point1_corner.x - box_dimension_x / 6, point1_corner.y + box_dimension_y / 2)
                                        let point_detected = new cv.Point(point1_corner.x - box_dimension_x / 3, point1_corner.y + box_dimension_y / 2)


                                        // bgr to hsv
                                        cv.cvtColor(src, hsv, cv.COLOR_BGR2HSV)

                                        // detect QR code for position detection
                                        rect_qr = new cv.Rect(Math.round(point1_corner.x + (1 / 17.7) * 0.8 * video.videoHeight), Math.round(point1_corner.y + (2.3 / 17.7) * 0.8 * video.videoHeight), Math.round((3.0 / 17.7) * 0.8 * video.videoHeight), Math.round((3.0 / 17.7) * 0.8 * video.videoHeight))
                                            // rect_qr = new cv.Rect(Math.round(point1_corner.x + (0.5 / 17.7) * 0.8 * video.videoHeight), Math.round(point1_corner.y + (1 / 17.7) * 0.8 * video.videoHeight), Math.round((3.0 / 17.7) * 0.8 * video.videoHeight), Math.round((3.0 / 17.7) * 0.8 * video.videoHeight))
                                        src_qr = src.roi(rect_qr)
                                        cv.cvtColor(src_qr, gray_qr, cv.COLOR_BGR2GRAY)
                                        cv.threshold(gray_qr, thresh_qr, thresh_black, 255, cv.THRESH_BINARY)
                                            // if (cv.countNonZero(thresh_qr) < 4000) {
                                            // console.log((cv.countNonZero(thresh_qr) / (thresh_qr.cols * thresh_qr.rows)) * 100)
                                        document.getElementById("logger").innerHTML = `${((cv.countNonZero(thresh_qr) / (thresh_qr.cols * thresh_qr.rows)) * 100)}`
                                            // console.log(white_percent)
                                        if (((cv.countNonZero(thresh_qr) / (thresh_qr.cols * thresh_qr.rows)) * 100) < white_percent) {
                                            correctPosition1 = true
                                                // console.log(thresh_qr.shape())
                                        } else {
                                            correctPosition1 = false
                                        }
                                        // console.log(cv.countNonZero(thresh_qr))

                                        let rect_ck1 = new cv.Rect(Math.round(point1_corner.x + (1.5 / 17.7) * 0.8 * video.videoHeight), Math.round(point1_corner.y + (11.0 / 17.7) * 0.8 * video.videoHeight), Math.round((2.0 / 17.7) * 0.8 * video.videoHeight), Math.round((1.0 / 17.7) * 0.8 * video.videoHeight))
                                        src_ck1 = src.roi(rect_ck1)
                                        cv.cvtColor(src_ck1, gray_ck1, cv.COLOR_BGR2GRAY)
                                        cv.threshold(gray_ck1, thresh_ck1, thresh_black, 255, cv.THRESH_BINARY)
                                            // if (cv.countNonZero(thresh_ck1) > 900) {
                                        if (((cv.countNonZero(thresh_ck1) / (thresh_ck1.cols * thresh_ck1.rows)) * 100) > 90) {
                                            correctPosition2 = true
                                        } else {
                                            correctPosition2 = false
                                        }
                                        // console.log(cv.countNonZero(thresh_ck1))

                                        let rect_ck2 = new cv.Rect(Math.round(point1_corner.x + (1.5 / 17.7) * 0.8 * video.videoHeight), Math.round(point1_corner.y + (16.0 / 17.7) * 0.8 * video.videoHeight), Math.round((2.0 / 17.7) * 0.8 * video.videoHeight), Math.round((1.0 / 17.7) * 0.8 * video.videoHeight))
                                        src_ck2 = src.roi(rect_ck2)
                                        cv.cvtColor(src_ck2, gray_ck2, cv.COLOR_BGR2GRAY)
                                        cv.threshold(gray_ck2, thresh_ck2, thresh_black, 255, cv.THRESH_BINARY)
                                            // if (cv.countNonZero(thresh_ck2) > 900) {
                                        if (((cv.countNonZero(thresh_ck2) / (thresh_ck2.cols * thresh_ck2.rows)) * 100) > 90) {
                                            correctPosition3 = true
                                        } else {
                                            correctPosition3 = false
                                        }
                                        // console.log(cv.countNonZero(thresh_ck2))

                                        let rect_ck3 = new cv.Rect(Math.round(point1_corner.x + (1.5 / 17.7) * 0.8 * video.videoHeight), Math.round(point1_corner.y + (0.4 / 17.7) * 0.8 * video.videoHeight), Math.round((2.0 / 17.7) * 0.8 * video.videoHeight), Math.round((1.0 / 17.7) * 0.8 * video.videoHeight))
                                        src_ck3 = src.roi(rect_ck3)
                                        cv.cvtColor(src_ck3, gray_ck3, cv.COLOR_BGR2GRAY)
                                        cv.threshold(gray_ck3, thresh_ck3, thresh_black, 255, cv.THRESH_BINARY)
                                            // if (cv.countNonZero(thresh_ck3) > 800) {
                                        if (((cv.countNonZero(thresh_ck3) / (thresh_ck3.cols * thresh_ck3.rows)) * 100) > 90) {
                                            correctPosition4 = true
                                        } else {
                                            correctPosition4 = false
                                        }
                                        // console.log(cv.countNonZero(thresh_ck2))

                                        // console.log(correctPosition1 && correctPosition2 && correctPosition3 && correctPosition4)




                                        // let detector = new cv.QRCodeDetector()
                                        // let point1_qr = new cv.Point(0, 0)
                                        // let point2_qr = new cv.Point(Math.round(point1_corner.y + (2.3 / 17.7) * 0.8 * video.videoHeight), Math.round((3.0 / 17.7) * 0.8 * video.videoHeight), Math.round((3.0 / 17.7) * 0.8 * video.videoHeight))
                                        // let result = detector.detectAndDecode(src_qr)
                                        // console.log(result)
                                        // console.log(detector.detect(src_qr, point_qr))


                                        // cv.cvtColor(src_qr, gray_qr, cv.COLOR_BGR2GRAY)
                                        // let ksize = new cv.Size(9, 9)
                                        // cv.GaussianBlur(gray_qr, blur_qr, ksize, 0, 0, cv.BORDER_DEFAULT)
                                        // cv.threshold(blur_qr, thresh_qr, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU)
                                        // let kernel = new cv.matFromArray(3, 3, cv.CV_32FC1, [1, 1, 1, 1, 1, 1, 1, 1])
                                        // let point = new cv.Point(0, 0)
                                        // cv.dilate(thresh_qr, dilate_qr, kernel)
                                        // cv.findContours(dilate_qr, contours_qr, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE)
                                        // console.log(contours_qr.size())


                                        // cv.findContours(thresh_qr, contours_qr, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMP)
                                        // cv.findContours(edg, contours, hierarchy, cv.RETR_TREE, 1);

                                        if (correctPosition1 && correctPosition2 && correctPosition3 && correctPosition4) {
                                            document.getElementById("status").classList.add('detected')
                                            document.getElementById("status").innerHTML = `<div style="color:black; font-size: 40px; text-align:center">Test Strip Detected</div>`
                                                // cropping hsv for c and t
                                            rect_c = new cv.Rect(Math.round(point1_corner.x + (2.1 / 17.7) * 0.8 * video.videoHeight), Math.round(point1_corner.y + (6.3 / 17.7) * 0.8 * video.videoHeight), Math.round((0.7 / 17.7) * 0.8 * video.videoHeight), Math.round((1.7 / 17.7) * 0.8 * video.videoHeight))
                                            rect_t = new cv.Rect(Math.round(point1_corner.x + (2.1 / 17.7) * 0.8 * video.videoHeight), Math.round(point1_corner.y + ((6.3 + 1.7) / 17.7) * 0.8 * video.videoHeight), Math.round((0.7 / 17.7) * 0.8 * video.videoHeight), Math.round((1.7 / 17.7) * 0.8 * video.videoHeight))
                                            hsv_c = hsv.roi(rect_c)
                                            hsv_t = hsv.roi(rect_t)

                                            // hsv in range
                                            let lower = [LH, LS, LV, 0];
                                            let higher = [HH, HS, HV, 0];
                                            let low = new cv.Mat(hsv_c.rows, hsv_c.cols, hsv_c.type(), lower);
                                            let high = new cv.Mat(hsv_c.rows, hsv_c.cols, hsv_c.type(), higher);
                                            cv.inRange(hsv_c, low, high, rng_c)
                                            cv.inRange(hsv_t, low, high, rng_t)

                                            low = new cv.Mat(hsv_qr.rows, hsv_qr.cols, hsv_qr.type(), lower);
                                            high = new cv.Mat(hsv_qr.rows, hsv_qr.cols, hsv_qr.type(), higher);
                                            cv.inRange(hsv_qr, low, high, rng_qr)
                                                // console.log(cv.countNonZero(rng_qr))

                                            // detect result lines of C & T
                                            hasC = cv.countNonZero(rng_c)
                                            hasT = cv.countNonZero(rng_t)
                                                // console.log(hasT)
                                            if (hasC && hasT) {
                                                // document.getElementById("status").innerHTML = `<div style="color:red; font-size: 25px; text-align:center">Result: Positive</div>`
                                                cv.putText(src, "Result : Positive", point_detected, cv.FONT_HERSHEY_SIMPLEX, 1, color_positive, 2, 2)

                                            } else if (hasC && !hasT) {
                                                // document.getElementById("status").innerHTML = `<div style="color:green; font-size: 25px; text-align:center">Result: Negative</div>`
                                                cv.putText(src, "Result : Negative", point_detected, cv.FONT_HERSHEY_SIMPLEX, 1, color_negative, 2, 2)
                                            } else {
                                                // document.getElementById("status").innerHTML = `<div style="color:purple; font-size: 25px; text-align:center">Result Invalid</div>`
                                                cv.putText(src, "Result : Invalid", point_detected, cv.FONT_HERSHEY_SIMPLEX, 1, color_invalid, 2, 2)
                                            }
                                        } else {
                                            document.getElementById("status").classList.remove('detected')
                                            document.getElementById("status").innerHTML = `<div style="color:black; font-size: 40px; text-align:center">Incorrect Position</div>`
                                            cv.putText(src, "Detecting...", point_detecting, cv.FONT_HERSHEY_SIMPLEX, 1, color_detecting, 2, 2)
                                                // cv.putText(src, "Result: Positive", point1_corner, cv.FONT_HERSHEY_SIMPLEX, 1, color, 3, 2)

                                        }

                                        // canny edge detection for qr
                                        // cv.Canny(rng_qr, edg_qr, 200, 600, 3, false)
                                        // low = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), lower);
                                        // high = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), higher);
                                        // cv.inRange(hsv, low, high, rng)
                                        // cv.Canny(rng, edg, 200, 600, 3, false)


                                        // // find contours
                                        // cv.findContours(edg, contours, hierarchy, cv.RETR_TREE, 1);
                                        // let cnt = contours.get(0);
                                        // for (let i = 0; i < contours.size(); ++i) {
                                        //     cv.drawContours(ctr, contours, i, color, 1, cv.LINE_8, hierarchy, 100);
                                        // }

                                        cv.imshow("canvas_opencv", thresh_ck2)

                                        cv.imshow("canvas", src);
                                        let delay = 1000 / FPS - (Date.now() - begin)
                                        setTimeout(processVideo, delay)
                                    } catch (err) {
                                        console.error(err)
                                            // clearInterval(interval)
                                            // interval = setInterval(processVideo, 200)
                                            // location.reload()
                                    }
                                }
                                // setTimeout(processVideo, 1000)
                                processVideo()
                                    // setInterval(processVideo, 200)

                                // getVideoFrame()
                                // ctx.drawImage(video, 0, 0, 750, 560);
                            }
                            setTimeout(opencv, 1000)
                        };
                    })
                    .catch(function(err) {
                        console.log(err.name + ": " + err.message);
                    });

                //get video frame
                function getVideoFrame() {
                    ctx.drawImage(video, 0, 0, 750, 560);
                    ctx_opencv.drawImage(video, 0, 0, 750, 560);
                    imageData = ctx.getImageData(0, 0, 750, 560);
                    //console.log("getVideoFrame");
                }
            }
        }
    </script>
    <!-- <script async src="opencv.js" onload="onOpenCvReady()"></script> -->
    <script async src="https://docs.opencv.org/master/opencv.js" type="text/javascript" onload="onOpenCvReady()"></script>

    <!-- <script async src="opencv.js"></script> -->


</body>

</html>