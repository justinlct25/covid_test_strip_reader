<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>ai</title>
	<style>
		video{
			width: 300px;
			height: 300px;
			border: 1px solid black;
		}
		canvas{
			width: 300px;
			height: 300px;
		}
	</style>
</head>
<body>
	<h1>Resnet18</h1>
	<div>
		<video id="video" autoplay="autoplay"></video>
		<button id="snap">Snap Photo</button>
		<canvas id="canvas"></canvas>
	</div>
	<div>
		<img id="imageSource" src="http://127.0.0.1:8080/cat.jpg" width="20%" height="20%"/>
		<input type="button" value="ImageRun" onclick="runAI()">
		<div id="predictions"></div>
	</div>
	<script>
	//resnet
	const imageSize = 224;
	
	async function runAI(){
		//create onnx inference with webgl
		const session = new onnx.InferenceSession({ backendHint: 'webgl' });
		
		//load onnx model
		await session.loadModel("http://127.0.0.1:8080/resnet18.onnx");
		
		let dateStart = new Date();
		//load img
		imageLoader = new ImageLoader(imageSize, imageSize);
		imageData = await imageLoader.getImageData("http://127.0.0.1:8080/cat.jpg");
		
		//preprocess img data
		const width = imageSize;
		const height = imageSize;
		const preprocessedData = preprocess(imageData.data, width, height);
		
		const inputTensor = new onnx.Tensor(preprocessedData, 'float32', [1, 3, width, height]);
		// Run model with Tensor inputs and get the result.
		const outputMap = await session.run([inputTensor]);
		const outputData = outputMap.values().next().value.data;
		
		let dateEnd = new Date();
		// Render the output result in html.
		console.log(outputData);
		findAndPrintMax(outputData, dateEnd.getTime() - dateStart.getTime());
	}
	
	function preprocess(data, width, height){
		const dataFromImage = ndarray(new Float32Array(data), [width, height, 4]);
		const dataProcessed = ndarray(new Float32Array(width * height * 3), [1, 3, height, width]);
		
		// Normalize 0-255 to (-1)-1
		ndarray.ops.divseq(dataFromImage, 128.0);
		ndarray.ops.subseq(dataFromImage, 1.0);

		// Realign imageData from [224*224*4] to the correct dimension [1*3*224*224].
		ndarray.ops.assign(dataProcessed.pick(0, 0, null, null), dataFromImage.pick(null, null, 2));
		ndarray.ops.assign(dataProcessed.pick(0, 1, null, null), dataFromImage.pick(null, null, 1));
		ndarray.ops.assign(dataProcessed.pick(0, 2, null, null), dataFromImage.pick(null, null, 0));

		return dataProcessed.data;
	}

	/**
	 * Render output to Html.
	 */
	function findAndPrintMax(data, time) {
		let maxValue = 0.0;
		let maxIndex = 0.0;
		
		predictions = document.getElementById('predictions');
		for(let i = 0; i < data.length; i++){
			if (data[i] > maxValue){
				maxValue = data[i];
				maxIndex = i;
			}
		}
		predictions.innerHTML = imagenetClasses[maxIndex] + ' : ' 
								+ (0 | data[maxIndex]*100) 
								+ "% Inference Time : " + time + "ms";
	}


	//video
	var video = document.querySelector('video');
	var canvas = document.querySelector('canvas');
	var ctx = canvas.getContext('2d');
	
    navigator.getUserMedia = navigator.getUserMedia ||
        navigator.webkitGetUserMedia ||
        navigator.mozGetUserMedia ||
        navigator.msGetUserMedia; //获取媒体对象（这里指摄像头）
    navigator.getUserMedia({
		audio: false,
        video: true,
    }, gotStream, noStream); //参数1获取用户打开权限；参数二成功打开后调用，并传一个视频流对象，参数三打开失败后调用，传错误信息
	
    function gotStream(stream) {
        video.srcObject = stream;
        video.onerror = function() {
            stream.stop();
        };
        stream.onended = noStream;
		video.play();
    }
 
    function noStream(err) {
        alert(err);
    }
 
    document.getElementById("snap").addEventListener("click", function() {
        ctx.drawImage(video, 0, 19, 300, 114); //将获取视频绘制在画布上
    });
	</script>
	<script src="https://cdn.jsdelivr.net/npm/onnxjs/dist/onnx.min.js"></script>
	<script src="http://127.0.0.1:8080/lib/ndarray-browser-min.js"></script>
	<script src="http://127.0.0.1:8080/lib/image-loader.js"></script>
	<script src="http://127.0.0.1:8080/lib/imagenetClasses.js"></script>
</body>
</html>